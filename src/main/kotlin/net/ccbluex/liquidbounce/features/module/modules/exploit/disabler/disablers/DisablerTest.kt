package net.ccbluex.liquidbounce.features.module.modules.exploit.disabler.disablers

import net.ccbluex.liquidbounce.config.ToggleableConfigurable
import net.ccbluex.liquidbounce.event.repeatable
import net.ccbluex.liquidbounce.features.module.modules.exploit.disabler.ModuleDisabler
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket
import net.minecraft.network.packet.c2s.play.PlayerInteractItemC2SPacket
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket
import net.minecraft.util.Hand
import net.minecraft.util.math.BlockPos
import net.minecraft.util.math.Direction
import kotlin.random.Random

internal object DisablerTest : ToggleableConfigurable(ModuleDisabler, "Prediction", false) {

    override fun enable() {
    }

    @Suppress("unused")
    val repeatable = repeatable {
        val randOffset = Random.nextDouble(-0.1, 0.1)
        val yawOffset = Random.nextDouble(-5.0, 5.0)

        /*network.sendPacket(
            PlayerMoveC2SPacket.PositionAndOnGround(
                player.x + randOffset,
                player.y,
                player.z + randOffset,
                player.isOnGround
            )
        )

        network.sendPacket(
            PlayerMoveC2SPacket.LookAndOnGround(
                player.yaw + yawOffset.toFloat(),
                player.pitch,
                player.isOnGround
            )
        )*/

        waitTicks(20)
        interaction.sendSequencedPacket(world) { sequence ->
            PlayerInteractItemC2SPacket(Hand.OFF_HAND, sequence, player.yaw, player.pitch)
        }
        network.sendPacket(
            PlayerActionC2SPacket(
                PlayerActionC2SPacket.Action.RELEASE_USE_ITEM, BlockPos(0, 0, 0), Direction.DOWN
            )
        )
    }
}
